{"abi":[{"type":"function","name":"parse","inputs":[{"name":"data","type":"bytes","internalType":"bytes"}],"outputs":[{"name":"bytecode","type":"bytes","internalType":"bytes"},{"name":"constants","type":"uint256[]","internalType":"uint256[]"}],"stateMutability":"pure"}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"parse(bytes)":"fab4087a"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.25+commit.b61c2a91\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"bytes\",\"name\":\"data\",\"type\":\"bytes\"}],\"name\":\"parse\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"bytecode\",\"type\":\"bytes\"},{\"internalType\":\"uint256[]\",\"name\":\"constants\",\"type\":\"uint256[]\"}],\"stateMutability\":\"pure\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"parse(bytes)\":{\"params\":{\"data\":\"The Rainlang bytes to parse.\"},\"returns\":{\"bytecode\":\"The expressions that can be evaluated.\",\"constants\":\"The constants that can be referenced by sources.\"}}},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"parse(bytes)\":{\"notice\":\"Parses a Rainlang string into an evaluable expression. MUST be deterministic and MUST NOT have side effects. The only inputs are the Rainlang string and the parse meta. MAY revert if the Rainlang string is invalid. This function takes `bytes` instead of `string` to allow for definitions of \\\"string\\\" other than UTF-8.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"lib/rain.interpreter.interface/src/interface/deprecated/IParserV1.sol\":\"IParserV1\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"appendCBOR\":false,\"bytecodeHash\":\"none\"},\"optimizer\":{\"enabled\":true,\"runs\":100000},\"remappings\":[\":bytecode/=lib/rain.interpreter.interface/src/lib/bytecode/\",\":caller/=lib/rain.interpreter.interface/src/lib/caller/\",\":codegen/=lib/rain.interpreter.interface/src/lib/codegen/\",\":deprecated/=lib/rain.interpreter.interface/src/lib/\",\":ds-test/=lib/openzeppelin-contracts-upgradeable/lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":mut/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.string/src/lib/mut/\",\":ns/=lib/rain.interpreter.interface/src/lib/ns/\",\":openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\":openzeppelin-contracts/=lib/rain.interpreter.interface/lib/openzeppelin-contracts/\",\":openzeppelin/=lib/openzeppelin-contracts-upgradeable/contracts/\",\":parse/=lib/rain.interpreter.interface/src/lib/parse/\",\":rain.datacontract/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.datacontract/src/\",\":rain.extrospection/=lib/rain.factory/lib/rain.extrospection/\",\":rain.factory/=lib/rain.factory/src/\",\":rain.interpreter.interface/=lib/rain.interpreter.interface/src/\",\":rain.intorastring/=lib/rain.interpreter.interface/lib/rain.intorastring/src/\",\":rain.lib.hash/=lib/rain.interpreter.interface/lib/rain.lib.hash/src/\",\":rain.lib.typecast/=lib/rain.interpreter.interface/lib/rain.lib.typecast/src/\",\":rain.math.binary/=lib/rain.interpreter.interface/lib/rain.math.binary/src/\",\":rain.math.fixedpoint/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.math.fixedpoint/src/\",\":rain.math.float/=lib/rain.interpreter.interface/lib/rain.math.float/\",\":rain.math.saturating/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.math.fixedpoint/lib/rain.math.saturating/src/\",\":rain.sol.codegen/=lib/rain.interpreter.interface/lib/rain.sol.codegen/\",\":rain.solmem/=lib/rain.solmem/src/\",\":rain.string/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.string/src/\"]},\"sources\":{\"lib/rain.interpreter.interface/src/interface/deprecated/IParserV1.sol\":{\"keccak256\":\"0x4f6a9e028942cebebfc84328193f1d31807aac292d9b82e2df489064aa913070\",\"license\":\"LicenseRef-DCL-1.0\",\"urls\":[\"bzz-raw://54073f63db1f652571472cb2d07de297772c2420e1571a0cb9e0a805ee4347e7\",\"dweb:/ipfs/QmXRqBreJvC8MQd5zLNgmPUdfFa4WD6gSoxvD8hecycux4\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.25+commit.b61c2a91"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"bytes","name":"data","type":"bytes"}],"stateMutability":"pure","type":"function","name":"parse","outputs":[{"internalType":"bytes","name":"bytecode","type":"bytes"},{"internalType":"uint256[]","name":"constants","type":"uint256[]"}]}],"devdoc":{"kind":"dev","methods":{"parse(bytes)":{"params":{"data":"The Rainlang bytes to parse."},"returns":{"bytecode":"The expressions that can be evaluated.","constants":"The constants that can be referenced by sources."}}},"version":1},"userdoc":{"kind":"user","methods":{"parse(bytes)":{"notice":"Parses a Rainlang string into an evaluable expression. MUST be deterministic and MUST NOT have side effects. The only inputs are the Rainlang string and the parse meta. MAY revert if the Rainlang string is invalid. This function takes `bytes` instead of `string` to allow for definitions of \"string\" other than UTF-8."}},"version":1}},"settings":{"remappings":["bytecode/=lib/rain.interpreter.interface/src/lib/bytecode/","caller/=lib/rain.interpreter.interface/src/lib/caller/","codegen/=lib/rain.interpreter.interface/src/lib/codegen/","deprecated/=lib/rain.interpreter.interface/src/lib/","ds-test/=lib/openzeppelin-contracts-upgradeable/lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/","forge-std/=lib/forge-std/src/","mut/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.string/src/lib/mut/","ns/=lib/rain.interpreter.interface/src/lib/ns/","openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/","openzeppelin-contracts/=lib/rain.interpreter.interface/lib/openzeppelin-contracts/","openzeppelin/=lib/openzeppelin-contracts-upgradeable/contracts/","parse/=lib/rain.interpreter.interface/src/lib/parse/","rain.datacontract/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.datacontract/src/","rain.extrospection/=lib/rain.factory/lib/rain.extrospection/","rain.factory/=lib/rain.factory/src/","rain.interpreter.interface/=lib/rain.interpreter.interface/src/","rain.intorastring/=lib/rain.interpreter.interface/lib/rain.intorastring/src/","rain.lib.hash/=lib/rain.interpreter.interface/lib/rain.lib.hash/src/","rain.lib.typecast/=lib/rain.interpreter.interface/lib/rain.lib.typecast/src/","rain.math.binary/=lib/rain.interpreter.interface/lib/rain.math.binary/src/","rain.math.fixedpoint/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.math.fixedpoint/src/","rain.math.float/=lib/rain.interpreter.interface/lib/rain.math.float/","rain.math.saturating/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.math.fixedpoint/lib/rain.math.saturating/src/","rain.sol.codegen/=lib/rain.interpreter.interface/lib/rain.sol.codegen/","rain.solmem/=lib/rain.solmem/src/","rain.string/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.string/src/"],"optimizer":{"enabled":true,"runs":100000},"metadata":{"bytecodeHash":"none","appendCBOR":false},"compilationTarget":{"lib/rain.interpreter.interface/src/interface/deprecated/IParserV1.sol":"IParserV1"},"evmVersion":"paris","libraries":{}},"sources":{"lib/rain.interpreter.interface/src/interface/deprecated/IParserV1.sol":{"keccak256":"0x4f6a9e028942cebebfc84328193f1d31807aac292d9b82e2df489064aa913070","urls":["bzz-raw://54073f63db1f652571472cb2d07de297772c2420e1571a0cb9e0a805ee4347e7","dweb:/ipfs/QmXRqBreJvC8MQd5zLNgmPUdfFa4WD6gSoxvD8hecycux4"],"license":"LicenseRef-DCL-1.0"}},"version":1},"id":28}