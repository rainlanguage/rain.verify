{"abi":[{"type":"function","name":"eval2","inputs":[{"name":"store","type":"address","internalType":"contract IInterpreterStoreV2"},{"name":"namespace","type":"uint256","internalType":"FullyQualifiedNamespace"},{"name":"dispatch","type":"uint256","internalType":"EncodedDispatch"},{"name":"context","type":"uint256[][]","internalType":"uint256[][]"},{"name":"inputs","type":"uint256[]","internalType":"uint256[]"}],"outputs":[{"name":"stack","type":"uint256[]","internalType":"uint256[]"},{"name":"writes","type":"uint256[]","internalType":"uint256[]"}],"stateMutability":"view"},{"type":"function","name":"functionPointers","inputs":[],"outputs":[{"name":"","type":"bytes","internalType":"bytes"}],"stateMutability":"view"}],"bytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"deployedBytecode":{"object":"0x","sourceMap":"","linkReferences":{}},"methodIdentifiers":{"eval2(address,uint256,uint256,uint256[][],uint256[])":"6046c5f9","functionPointers()":"f933c72f"},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.25+commit.b61c2a91\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"contract IInterpreterStoreV2\",\"name\":\"store\",\"type\":\"address\"},{\"internalType\":\"FullyQualifiedNamespace\",\"name\":\"namespace\",\"type\":\"uint256\"},{\"internalType\":\"EncodedDispatch\",\"name\":\"dispatch\",\"type\":\"uint256\"},{\"internalType\":\"uint256[][]\",\"name\":\"context\",\"type\":\"uint256[][]\"},{\"internalType\":\"uint256[]\",\"name\":\"inputs\",\"type\":\"uint256[]\"}],\"name\":\"eval2\",\"outputs\":[{\"internalType\":\"uint256[]\",\"name\":\"stack\",\"type\":\"uint256[]\"},{\"internalType\":\"uint256[]\",\"name\":\"writes\",\"type\":\"uint256[]\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"functionPointers\",\"outputs\":[{\"internalType\":\"bytes\",\"name\":\"\",\"type\":\"bytes\"}],\"stateMutability\":\"view\",\"type\":\"function\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{\"eval2(address,uint256,uint256,uint256[][],uint256[])\":{\"params\":{\"context\":\"A 2-dimensional array of data that can be indexed into at runtime by the interpreter. The calling contract is responsible for ensuring the authenticity and completeness of context data. The interpreter MUST revert at runtime if an expression attempts to index into some context value that is not provided by the caller. This implies that context reads cannot be checked for out of bounds reads at deploy time, as the runtime context MAY be provided in a different shape to what the expression is expecting.\",\"dispatch\":\"All the information required for the interpreter to load an expression, select an entrypoint and return the values expected by the caller. The interpreter MAY encode dispatches differently to `LibEncodedDispatch` but this WILL negatively impact compatibility for calling contracts that hardcode the encoding logic.\",\"inputs\":\"The inputs to the entrypoint stack of the expression. MAY be empty if the caller prefers to specify all inputs via. context.\",\"namespace\":\"The fully qualified namespace that will be used by the interpreter at runtime in order to perform gets on the underlying store.\",\"store\":\"The storage contract that the returned key/value pairs MUST be passed to IF the calling contract is in a non-static calling context. Static calling contexts MUST pass `address(0)`.\"},\"returns\":{\"stack\":\"The list of values produced by evaluating the expression. MUST NOT be longer than the maximum length specified by `dispatch`, if applicable. MUST be ordered such that the top of the stack is the FIRST item in the array.\",\"writes\":\"A list of values to be processed by a store. Most likely will be pairwise key/value items but this is not strictly required if some store expects some other format.\"}}},\"title\":\"IInterpreterV2 Interface into a standard interpreter that supports: - evaluating `view` logic deployed onchain by an `IExpressionDeployerV1` - receiving arbitrary `uint256[][]` supporting context to be made available   to the evaluated logic - handling subsequent state changes in bulk in response to evaluated logic - namespacing state changes according to the caller's preferences to avoid   unwanted key collisions - exposing its internal function pointers to support external precompilation   of logic for more gas efficient runtime evaluation by the interpreter The interface is designed to be stable across many versions and implementations of an interpreter, balancing minimalism with features required for a general purpose onchain interpreted compute environment. The security model of an interpreter is that it MUST be resilient to malicious expressions even if they dispatch arbitrary internal function pointers during an eval. The interpreter MAY return garbage or exhibit undefined behaviour or error during an eval, _provided that no state changes are persisted_ e.g. in storage, such that only the caller that specifies the malicious expression can be negatively impacted by the result. In turn, the caller must guard itself against arbitrarily corrupt/malicious reverts and return values from any interpreter that it requests an expression from. And so on and so forth up to the externally owned account (EOA) who signs the transaction and agrees to a specific combination of contracts, expressions and interpreters, who can presumably make an informed decision about which ones to trust to get the job done. The state changes for an interpreter are expected to be produced by an `eval2` and passed to the `IInterpreterStoreV1` returned by the eval, as-is by the caller, after the caller has had an opportunity to apply their own intermediate logic such as reentrancy defenses against malicious interpreters. The interpreter is free to structure the state changes however it wants but MUST guard against the calling contract corrupting the changes between `eval2` and `set`. For example a store could sandbox storage writes per-caller so that a malicious caller can only damage their own state changes, while honest callers respect, benefit from and are protected by the interpreter store's state change handling. The two step eval-state model allows evaluation to be read-only which provides security guarantees for the caller such as no stateful reentrancy, either from the interpreter or some contract interface used by some word, while still allowing for storage writes. As the storage writes happen on the interpreter rather than the caller (c.f. delegate call) the caller DOES NOT need to trust the interpreter, which allows for permissionless selection of interpreters by end users. Delegate call always implies an admin key on the caller because the delegatee contract can write arbitrarily to the state of the delegator, which severely limits the generality of contract composition.\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{\"eval2(address,uint256,uint256,uint256[][],uint256[])\":{\"notice\":\"The raison d'etre for an interpreter. Given some expression and per-call additional contextual data, produce a stack of results and a set of state changes that the caller MAY OPTIONALLY pass back to be persisted by a call to `IInterpreterStoreV1.set`. There are two key differences between `eval` and `eval2`: - `eval` was ambiguous about whether the top value of the final stack is the first or last item of the array. `eval2` is unambiguous in that the top of the stack MUST be the first item in the array. - `eval2` allows the caller to specify inputs to the entrypoint stack of the expression. This allows the `eval` and `offchainDebugEval` functions to be merged into a single function that can be used for both onchain and offchain evaluation. For example, the caller can simulate \\\"internal\\\" calls by specifying the inputs to the entrypoint stack of the expression as the outputs of some other expression. Legacy behaviour can be achieved by passing an empty array for `inputs`.\"},\"functionPointers()\":{\"notice\":\"Exposes the function pointers as `uint16` values packed into a single `bytes` in the same order as they would be indexed into by opcodes. For example, if opcode `2` should dispatch function at position `0x1234` then the start of the returned bytes would be `0xXXXXXXXX1234` where `X` is a placeholder for the function pointers of opcodes `0` and `1`. `IExpressionDeployerV3` contracts use these function pointers to \\\"compile\\\" the expression into something that an interpreter can dispatch directly without paying gas to lookup the same at runtime. As the validity of any integrity check and subsequent dispatch is highly sensitive to both the function pointers and overall bytecode of the interpreter, `IExpressionDeployerV3` contracts SHOULD implement guards against accidentally being deployed onchain paired against an unknown interpreter. It is very easy for an apparent compatible pairing to be subtly and critically incompatible due to addition/removal/reordering of opcodes and compiler optimisations on the interpreter bytecode. This MAY return different values during construction vs. all other times after the interpreter has been successfully deployed onchain. DO NOT rely on function pointers reported during contract construction.\"}},\"version\":1}},\"settings\":{\"compilationTarget\":{\"lib/rain.interpreter.interface/src/interface/deprecated/IInterpreterV2.sol\":\"IInterpreterV2\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"appendCBOR\":false,\"bytecodeHash\":\"none\"},\"optimizer\":{\"enabled\":true,\"runs\":100000},\"remappings\":[\":bytecode/=lib/rain.interpreter.interface/src/lib/bytecode/\",\":caller/=lib/rain.interpreter.interface/src/lib/caller/\",\":codegen/=lib/rain.interpreter.interface/src/lib/codegen/\",\":deprecated/=lib/rain.interpreter.interface/src/lib/\",\":ds-test/=lib/openzeppelin-contracts-upgradeable/lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":mut/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.string/src/lib/mut/\",\":ns/=lib/rain.interpreter.interface/src/lib/ns/\",\":openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\":openzeppelin-contracts/=lib/rain.interpreter.interface/lib/openzeppelin-contracts/\",\":openzeppelin/=lib/openzeppelin-contracts-upgradeable/contracts/\",\":parse/=lib/rain.interpreter.interface/src/lib/parse/\",\":rain.datacontract/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.datacontract/src/\",\":rain.extrospection/=lib/rain.factory/lib/rain.extrospection/\",\":rain.factory/=lib/rain.factory/src/\",\":rain.interpreter.interface/=lib/rain.interpreter.interface/src/\",\":rain.intorastring/=lib/rain.interpreter.interface/lib/rain.intorastring/src/\",\":rain.lib.hash/=lib/rain.interpreter.interface/lib/rain.lib.hash/src/\",\":rain.lib.typecast/=lib/rain.interpreter.interface/lib/rain.lib.typecast/src/\",\":rain.math.binary/=lib/rain.interpreter.interface/lib/rain.math.binary/src/\",\":rain.math.fixedpoint/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.math.fixedpoint/src/\",\":rain.math.float/=lib/rain.interpreter.interface/lib/rain.math.float/\",\":rain.math.saturating/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.math.fixedpoint/lib/rain.math.saturating/src/\",\":rain.sol.codegen/=lib/rain.interpreter.interface/lib/rain.sol.codegen/\",\":rain.solmem/=lib/rain.solmem/src/\",\":rain.string/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.string/src/\"]},\"sources\":{\"lib/rain.interpreter.interface/src/interface/IInterpreterStoreV2.sol\":{\"keccak256\":\"0x89b7dfa624962983c42da404fc8653daa29e793a60f11a2d9c8a9cf34caaf71a\",\"license\":\"LicenseRef-DCL-1.0\",\"urls\":[\"bzz-raw://10dcc56124d4a054ad13227e6098b7ceda11bbeccd8bb38d1e57da542285f72d\",\"dweb:/ipfs/QmUSgcm3Hpifk4GyjGMssJfo2Pea9dMm9sP4AzyzGfVA5c\"]},\"lib/rain.interpreter.interface/src/interface/deprecated/IInterpreterStoreV1.sol\":{\"keccak256\":\"0x7d2bc86fefbe372fc64381b320244fe9dbda1816867f3040c5bb3951869fe6a7\",\"license\":\"LicenseRef-DCL-1.0\",\"urls\":[\"bzz-raw://90c371494080129d5acd2bc52d092fc5cfe559147f7fc855ed01e62a7837f21e\",\"dweb:/ipfs/QmcNtPDuTxic8zqRFXf1ba6FJKmQXguxiDUY4E7wjyVwU5\"]},\"lib/rain.interpreter.interface/src/interface/deprecated/IInterpreterV1.sol\":{\"keccak256\":\"0xe0b94c771a7b6aa05388b4db6e238e36a4653cbfdbd3e54bbcaa7a97fc9491f4\",\"license\":\"LicenseRef-DCL-1.0\",\"urls\":[\"bzz-raw://59887a7f2ef60669906c5e70831ac0c9a7345313b04efb306235280f85e1db73\",\"dweb:/ipfs/QmP6Ny9m3sPCP65UmgGGpucSMgVAoDv6qURqyxUE95VU5Q\"]},\"lib/rain.interpreter.interface/src/interface/deprecated/IInterpreterV2.sol\":{\"keccak256\":\"0xa785ce2ac17059933b74aa3c8bd51321694ba8ddf27f2767ef99ea002faae1c6\",\"license\":\"LicenseRef-DCL-1.0\",\"urls\":[\"bzz-raw://130555df49552cf6865c4e82d6e67dd115151de2cd2161fb138849992d6a7a82\",\"dweb:/ipfs/QmRvrAGrkk3zgiG9Rox7m9wwzJL6B8ZcQAQvJpYKbvXvTS\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.25+commit.b61c2a91"},"language":"Solidity","output":{"abi":[{"inputs":[{"internalType":"contract IInterpreterStoreV2","name":"store","type":"address"},{"internalType":"FullyQualifiedNamespace","name":"namespace","type":"uint256"},{"internalType":"EncodedDispatch","name":"dispatch","type":"uint256"},{"internalType":"uint256[][]","name":"context","type":"uint256[][]"},{"internalType":"uint256[]","name":"inputs","type":"uint256[]"}],"stateMutability":"view","type":"function","name":"eval2","outputs":[{"internalType":"uint256[]","name":"stack","type":"uint256[]"},{"internalType":"uint256[]","name":"writes","type":"uint256[]"}]},{"inputs":[],"stateMutability":"view","type":"function","name":"functionPointers","outputs":[{"internalType":"bytes","name":"","type":"bytes"}]}],"devdoc":{"kind":"dev","methods":{"eval2(address,uint256,uint256,uint256[][],uint256[])":{"params":{"context":"A 2-dimensional array of data that can be indexed into at runtime by the interpreter. The calling contract is responsible for ensuring the authenticity and completeness of context data. The interpreter MUST revert at runtime if an expression attempts to index into some context value that is not provided by the caller. This implies that context reads cannot be checked for out of bounds reads at deploy time, as the runtime context MAY be provided in a different shape to what the expression is expecting.","dispatch":"All the information required for the interpreter to load an expression, select an entrypoint and return the values expected by the caller. The interpreter MAY encode dispatches differently to `LibEncodedDispatch` but this WILL negatively impact compatibility for calling contracts that hardcode the encoding logic.","inputs":"The inputs to the entrypoint stack of the expression. MAY be empty if the caller prefers to specify all inputs via. context.","namespace":"The fully qualified namespace that will be used by the interpreter at runtime in order to perform gets on the underlying store.","store":"The storage contract that the returned key/value pairs MUST be passed to IF the calling contract is in a non-static calling context. Static calling contexts MUST pass `address(0)`."},"returns":{"stack":"The list of values produced by evaluating the expression. MUST NOT be longer than the maximum length specified by `dispatch`, if applicable. MUST be ordered such that the top of the stack is the FIRST item in the array.","writes":"A list of values to be processed by a store. Most likely will be pairwise key/value items but this is not strictly required if some store expects some other format."}}},"version":1},"userdoc":{"kind":"user","methods":{"eval2(address,uint256,uint256,uint256[][],uint256[])":{"notice":"The raison d'etre for an interpreter. Given some expression and per-call additional contextual data, produce a stack of results and a set of state changes that the caller MAY OPTIONALLY pass back to be persisted by a call to `IInterpreterStoreV1.set`. There are two key differences between `eval` and `eval2`: - `eval` was ambiguous about whether the top value of the final stack is the first or last item of the array. `eval2` is unambiguous in that the top of the stack MUST be the first item in the array. - `eval2` allows the caller to specify inputs to the entrypoint stack of the expression. This allows the `eval` and `offchainDebugEval` functions to be merged into a single function that can be used for both onchain and offchain evaluation. For example, the caller can simulate \"internal\" calls by specifying the inputs to the entrypoint stack of the expression as the outputs of some other expression. Legacy behaviour can be achieved by passing an empty array for `inputs`."},"functionPointers()":{"notice":"Exposes the function pointers as `uint16` values packed into a single `bytes` in the same order as they would be indexed into by opcodes. For example, if opcode `2` should dispatch function at position `0x1234` then the start of the returned bytes would be `0xXXXXXXXX1234` where `X` is a placeholder for the function pointers of opcodes `0` and `1`. `IExpressionDeployerV3` contracts use these function pointers to \"compile\" the expression into something that an interpreter can dispatch directly without paying gas to lookup the same at runtime. As the validity of any integrity check and subsequent dispatch is highly sensitive to both the function pointers and overall bytecode of the interpreter, `IExpressionDeployerV3` contracts SHOULD implement guards against accidentally being deployed onchain paired against an unknown interpreter. It is very easy for an apparent compatible pairing to be subtly and critically incompatible due to addition/removal/reordering of opcodes and compiler optimisations on the interpreter bytecode. This MAY return different values during construction vs. all other times after the interpreter has been successfully deployed onchain. DO NOT rely on function pointers reported during contract construction."}},"version":1}},"settings":{"remappings":["bytecode/=lib/rain.interpreter.interface/src/lib/bytecode/","caller/=lib/rain.interpreter.interface/src/lib/caller/","codegen/=lib/rain.interpreter.interface/src/lib/codegen/","deprecated/=lib/rain.interpreter.interface/src/lib/","ds-test/=lib/openzeppelin-contracts-upgradeable/lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/","forge-std/=lib/forge-std/src/","mut/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.string/src/lib/mut/","ns/=lib/rain.interpreter.interface/src/lib/ns/","openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/","openzeppelin-contracts/=lib/rain.interpreter.interface/lib/openzeppelin-contracts/","openzeppelin/=lib/openzeppelin-contracts-upgradeable/contracts/","parse/=lib/rain.interpreter.interface/src/lib/parse/","rain.datacontract/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.datacontract/src/","rain.extrospection/=lib/rain.factory/lib/rain.extrospection/","rain.factory/=lib/rain.factory/src/","rain.interpreter.interface/=lib/rain.interpreter.interface/src/","rain.intorastring/=lib/rain.interpreter.interface/lib/rain.intorastring/src/","rain.lib.hash/=lib/rain.interpreter.interface/lib/rain.lib.hash/src/","rain.lib.typecast/=lib/rain.interpreter.interface/lib/rain.lib.typecast/src/","rain.math.binary/=lib/rain.interpreter.interface/lib/rain.math.binary/src/","rain.math.fixedpoint/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.math.fixedpoint/src/","rain.math.float/=lib/rain.interpreter.interface/lib/rain.math.float/","rain.math.saturating/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.math.fixedpoint/lib/rain.math.saturating/src/","rain.sol.codegen/=lib/rain.interpreter.interface/lib/rain.sol.codegen/","rain.solmem/=lib/rain.solmem/src/","rain.string/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.string/src/"],"optimizer":{"enabled":true,"runs":100000},"metadata":{"bytecodeHash":"none","appendCBOR":false},"compilationTarget":{"lib/rain.interpreter.interface/src/interface/deprecated/IInterpreterV2.sol":"IInterpreterV2"},"evmVersion":"paris","libraries":{}},"sources":{"lib/rain.interpreter.interface/src/interface/IInterpreterStoreV2.sol":{"keccak256":"0x89b7dfa624962983c42da404fc8653daa29e793a60f11a2d9c8a9cf34caaf71a","urls":["bzz-raw://10dcc56124d4a054ad13227e6098b7ceda11bbeccd8bb38d1e57da542285f72d","dweb:/ipfs/QmUSgcm3Hpifk4GyjGMssJfo2Pea9dMm9sP4AzyzGfVA5c"],"license":"LicenseRef-DCL-1.0"},"lib/rain.interpreter.interface/src/interface/deprecated/IInterpreterStoreV1.sol":{"keccak256":"0x7d2bc86fefbe372fc64381b320244fe9dbda1816867f3040c5bb3951869fe6a7","urls":["bzz-raw://90c371494080129d5acd2bc52d092fc5cfe559147f7fc855ed01e62a7837f21e","dweb:/ipfs/QmcNtPDuTxic8zqRFXf1ba6FJKmQXguxiDUY4E7wjyVwU5"],"license":"LicenseRef-DCL-1.0"},"lib/rain.interpreter.interface/src/interface/deprecated/IInterpreterV1.sol":{"keccak256":"0xe0b94c771a7b6aa05388b4db6e238e36a4653cbfdbd3e54bbcaa7a97fc9491f4","urls":["bzz-raw://59887a7f2ef60669906c5e70831ac0c9a7345313b04efb306235280f85e1db73","dweb:/ipfs/QmP6Ny9m3sPCP65UmgGGpucSMgVAoDv6qURqyxUE95VU5Q"],"license":"LicenseRef-DCL-1.0"},"lib/rain.interpreter.interface/src/interface/deprecated/IInterpreterV2.sol":{"keccak256":"0xa785ce2ac17059933b74aa3c8bd51321694ba8ddf27f2767ef99ea002faae1c6","urls":["bzz-raw://130555df49552cf6865c4e82d6e67dd115151de2cd2161fb138849992d6a7a82","dweb:/ipfs/QmRvrAGrkk3zgiG9Rox7m9wwzJL6B8ZcQAQvJpYKbvXvTS"],"license":"LicenseRef-DCL-1.0"}},"version":1},"id":27}