{"abi":[],"bytecode":{"object":"0x60206037600b82828239805160001a607314602a57634e487b7160e01b600052600060045260246000fd5b30600052607381538281f3fe73000000000000000000000000000000000000000030146080604052600080fd","sourceMap":"3556:893:18:-:0;;;;;;;;;;;;;;;-1:-1:-1;;;3556:893:18;;;;;;;;;;;;;;;;;","linkReferences":{}},"deployedBytecode":{"object":"0x73000000000000000000000000000000000000000030146080604052600080fd","sourceMap":"3556:893:18:-:0;;;;;;;;","linkReferences":{}},"methodIdentifiers":{},"rawMetadata":"{\"compiler\":{\"version\":\"0.8.25+commit.b61c2a91\"},\"language\":\"Solidity\",\"output\":{\"abi\":[],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"title\":\"LibHashNoAlloc\",\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"notice\":\"When producing hashes of just about anything that isn't already bytes the common suggestions look something like `keccak256(abi.encode(...))` or `keccak256(abi.encodePacked(...))` with the main differentiation being whether dynamic data types are being hashed. If they are then there is a hash collision risk in the packed case as `\\\"abc\\\" + \\\"def\\\"` and `\\\"ab\\\" + \\\"cdef\\\"` will pack and therefore hash to the same values, the suggested fix commonly being to use abi.encode, which includes the lengths disambiguating dynamic data. Something like `3\\\"abc\\\" + 3\\\"def\\\"` with the length prefixes won't collide with `2\\\"ab\\\" + 4\\\"cdef\\\"` but note that ABI provides neither a strong guarantee to be collision resitant on inputs (as far as I know, it's a coincidence that this works), nor an efficient solution. - Abi encoding is a complex algorithm that is easily 1k+ gas for simple   structs with just one or two dynamic typed fields. - Abi encoding requires allocating and copying all the data plus a header to   a new region of memory, which gives it non-linearly increasing costs due to   memory expansion. - Abi encoding can't easily be reproduced offchain without specialised tools,   it's not simply a matter of length prefixing some byte string and hashing   with keccak256, the heads and tails all need to be produced recursively   https://docs.soliditylang.org/en/develop/abi-spec.html#formal-specification-of-the-encoding Consider that `hash(hash(\\\"abc\\\") + hash(\\\"def\\\"))` won't collide with `hash(hash(\\\"ab\\\") + hash(\\\"cdef\\\"))`. It should be easier to convince ourselves this is true for all possible pairs of byte strings than it is to convince ourselves that the ABI serialization is never ambigious. Inductively we can scale this to all possible data structures that are ordered compositions of byte strings. Even better, the native behaviour of `keccak256` in the EVM requires no additional allocation of memory. Worst case scenario is that we want to hash several hashes together like `hash(hash0, hash1, ...)`, in which case we can write the words after the free memory pointer, hash them, but leave the pointer. This way we pay for memory expansion but can re-use that region of memory for subsequent logic, which may effectively make the expansion free as we would have needed to pay for it anyway. Given that hash checks often occur early in real world logic due to checks-effects-interactions, this is not an unreasonable assumption to call this kind of expansion \\\"no alloc\\\". One problem is that the gas saving for trivial abi encoding, e.g. ~1-3 uint256 values, can be lost by the overhead of jumps and stack manipulation due to function calls. ``` struct Foo {   uint256 a;   address b;   uint32 c; } ``` The simplest way to hash `Foo` is to just hash it (crazy, i know!). ``` assembly (\\\"memory-safe\\\") {   hash_ := keccak256(foo_, 0x60) } ``` Every struct field is 0x20 bytes in memory so 3 fields = 0x60 bytes to hash always, with the exception of dynamic types. This costs about 70 gas vs. about 350 gas for an abi encoding based approach.\",\"version\":1}},\"settings\":{\"compilationTarget\":{\"lib/rain.interpreter.interface/lib/rain.lib.hash/src/LibHashNoAlloc.sol\":\"LibHashNoAlloc\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"appendCBOR\":false,\"bytecodeHash\":\"none\"},\"optimizer\":{\"enabled\":true,\"runs\":100000},\"remappings\":[\":bytecode/=lib/rain.interpreter.interface/src/lib/bytecode/\",\":caller/=lib/rain.interpreter.interface/src/lib/caller/\",\":codegen/=lib/rain.interpreter.interface/src/lib/codegen/\",\":deprecated/=lib/rain.interpreter.interface/src/lib/\",\":ds-test/=lib/openzeppelin-contracts-upgradeable/lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":mut/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.string/src/lib/mut/\",\":ns/=lib/rain.interpreter.interface/src/lib/ns/\",\":openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\":openzeppelin-contracts/=lib/rain.interpreter.interface/lib/openzeppelin-contracts/\",\":openzeppelin/=lib/openzeppelin-contracts-upgradeable/contracts/\",\":parse/=lib/rain.interpreter.interface/src/lib/parse/\",\":rain.datacontract/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.datacontract/src/\",\":rain.extrospection/=lib/rain.factory/lib/rain.extrospection/\",\":rain.factory/=lib/rain.factory/src/\",\":rain.interpreter.interface/=lib/rain.interpreter.interface/src/\",\":rain.intorastring/=lib/rain.interpreter.interface/lib/rain.intorastring/src/\",\":rain.lib.hash/=lib/rain.interpreter.interface/lib/rain.lib.hash/src/\",\":rain.lib.typecast/=lib/rain.interpreter.interface/lib/rain.lib.typecast/src/\",\":rain.math.binary/=lib/rain.interpreter.interface/lib/rain.math.binary/src/\",\":rain.math.fixedpoint/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.math.fixedpoint/src/\",\":rain.math.float/=lib/rain.interpreter.interface/lib/rain.math.float/\",\":rain.math.saturating/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.math.fixedpoint/lib/rain.math.saturating/src/\",\":rain.sol.codegen/=lib/rain.interpreter.interface/lib/rain.sol.codegen/\",\":rain.solmem/=lib/rain.solmem/src/\",\":rain.string/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.string/src/\"]},\"sources\":{\"lib/rain.interpreter.interface/lib/rain.lib.hash/src/LibHashNoAlloc.sol\":{\"keccak256\":\"0x1153c2d2ec53adca83c81c37ac958aab8b4d31e0e01f64f5189b1783375c0347\",\"license\":\"LicenseRef-DCL-1.0\",\"urls\":[\"bzz-raw://79d10d5165cf0d5cc8b28b76613fc114e74c33fcc2d5632f7e284dace2247927\",\"dweb:/ipfs/QmZEt4BQ6xsfiFNBQ55GoQq8Ats3Hb1v2hPFEWPDeqKrTv\"]}},\"version\":1}","metadata":{"compiler":{"version":"0.8.25+commit.b61c2a91"},"language":"Solidity","output":{"abi":[],"devdoc":{"kind":"dev","methods":{},"version":1},"userdoc":{"kind":"user","methods":{},"version":1}},"settings":{"remappings":["bytecode/=lib/rain.interpreter.interface/src/lib/bytecode/","caller/=lib/rain.interpreter.interface/src/lib/caller/","codegen/=lib/rain.interpreter.interface/src/lib/codegen/","deprecated/=lib/rain.interpreter.interface/src/lib/","ds-test/=lib/openzeppelin-contracts-upgradeable/lib/forge-std/lib/ds-test/src/","erc4626-tests/=lib/openzeppelin-contracts-upgradeable/lib/erc4626-tests/","forge-std/=lib/forge-std/src/","mut/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.string/src/lib/mut/","ns/=lib/rain.interpreter.interface/src/lib/ns/","openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/","openzeppelin-contracts/=lib/rain.interpreter.interface/lib/openzeppelin-contracts/","openzeppelin/=lib/openzeppelin-contracts-upgradeable/contracts/","parse/=lib/rain.interpreter.interface/src/lib/parse/","rain.datacontract/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.datacontract/src/","rain.extrospection/=lib/rain.factory/lib/rain.extrospection/","rain.factory/=lib/rain.factory/src/","rain.interpreter.interface/=lib/rain.interpreter.interface/src/","rain.intorastring/=lib/rain.interpreter.interface/lib/rain.intorastring/src/","rain.lib.hash/=lib/rain.interpreter.interface/lib/rain.lib.hash/src/","rain.lib.typecast/=lib/rain.interpreter.interface/lib/rain.lib.typecast/src/","rain.math.binary/=lib/rain.interpreter.interface/lib/rain.math.binary/src/","rain.math.fixedpoint/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.math.fixedpoint/src/","rain.math.float/=lib/rain.interpreter.interface/lib/rain.math.float/","rain.math.saturating/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.math.fixedpoint/lib/rain.math.saturating/src/","rain.sol.codegen/=lib/rain.interpreter.interface/lib/rain.sol.codegen/","rain.solmem/=lib/rain.solmem/src/","rain.string/=lib/rain.interpreter.interface/lib/rain.math.float/lib/rain.string/src/"],"optimizer":{"enabled":true,"runs":100000},"metadata":{"bytecodeHash":"none","appendCBOR":false},"compilationTarget":{"lib/rain.interpreter.interface/lib/rain.lib.hash/src/LibHashNoAlloc.sol":"LibHashNoAlloc"},"evmVersion":"paris","libraries":{}},"sources":{"lib/rain.interpreter.interface/lib/rain.lib.hash/src/LibHashNoAlloc.sol":{"keccak256":"0x1153c2d2ec53adca83c81c37ac958aab8b4d31e0e01f64f5189b1783375c0347","urls":["bzz-raw://79d10d5165cf0d5cc8b28b76613fc114e74c33fcc2d5632f7e284dace2247927","dweb:/ipfs/QmZEt4BQ6xsfiFNBQ55GoQq8Ats3Hb1v2hPFEWPDeqKrTv"],"license":"LicenseRef-DCL-1.0"}},"version":1},"id":18}